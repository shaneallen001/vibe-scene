
import fs from 'fs';
import path from 'path';
import { JSDOM } from 'jsdom';
import { fileURLToPath } from 'url';
import crypto from 'crypto';

// --- Mock Browser Environment ---
const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>');
global.window = dom.window;
global.document = dom.window.document;
global.fetch = async () => ({ ok: true, json: async () => ({}) }); // Mock fetch
global.crypto = crypto;
if (!global.crypto.randomUUID) {
    global.crypto.randomUUID = () => crypto.randomUUID();
}

// Mock Game Global
global.game = {
    settings: {
        get: (module, key) => {
            if (key === 'geminiApiKey') return null;
            if (key === 'defaultGridSize') return 20;
            return null;
        }
    }
};

// Mock UI Global
global.ui = {
    notifications: {
        info: () => { },
        error: () => { }
    }
};

// --- Imports ---
// We need to mock the dependencies of DungeongenService
// The service imports:
// import { generateDungeonWithData } from '../dungeongen/dungeongen.js';
// import { AssetLibraryService } from './asset-library-service.js';
// import { AiAssetService } from './ai-asset-service.js';

// We can rely on the real dungeongen, but we need to mock AssetLibraryService to avoid file system/network calls
// and ensuring it returns known assets.

// Since we cannot easily mock ES6 imports without a loader or test runner, 
// we will assign a Mock class to the global scope or simply monkey-patch the prototype AFTER import if possible,
// OR we can just rely on the fact that AssetLibraryService.load() will fail or return empty, 
// and we can manually inject assets into the service instance.

const { DungeongenService } = await import('../scripts/services/dungeongen-service.js');

async function test() {
    console.log("Starting Item Placement Verification...");

    const service = new DungeongenService();

    // Mock the library to return a dummy asset
    service.library = {
        load: async () => { },
        getAssets: (type) => {
            if (type === 'OBJECT') {
                return [{ path: 'dummy/path.png', type: 'OBJECT', tags: ['box'] }];
            }
            return [];
        }
    };

    const gridSize = 20;
    const padding = gridSize * 2; // Fixed padding from renderer

    const options = {
        size: 'medium', // Ensure we have large enough rooms
        gridSize: gridSize,
        seed: 12345, // Fixed seed for reproducibility
        density: 1.0, // High density to ensure rooms
    };

    try {
        // We use _populateRooms internally, or call generate
        // Let's call generate, but we need to mock generateDungeonWithData? 
        // No, we want real dungeon data.

        // However, generate() calls generateDungeonWithData which uses canvas.
        // We need the mock canvas setup from test_generator.js
        setupCanvasMock();

        const result = await service.generate(options);
        const { items, walls } = result;

        // We need the room data to verify. 
        // service.generate returns { blob, walls, items }, but NOT the grid/room data directly.
        // The service internally calls generateDungeonWithData which returns { dungeon, blob, walls }.
        // But the service swallows the 'dungeon' object in its return.

        // To verify, we have to inspect the internal logic or modify the service to return grid, 
        // OR we can just check if items are "Reasonable" (positive coordinates, not 0,0 if that was the bug).
        // The bug was "outside the rooms".

        // Wait, I can reconstruct the rooms from the walls? No, too hard.
        // I should temporarily modify the service to return the grid OR key off the verify script 
        // to call generateDungeonWithData directly and then validat the logic duplication.

        // Better: Instantiate the Generator directly, get the rooms, then call _populateRooms private method.
        // Yes, access _populateRooms directly.

        const { generateDungeonWithData } = await import('../scripts/dungeongen/dungeongen.js');
        const data = await generateDungeonWithData(options);
        const grid = data.dungeon;

        // Reset items to be generated by our service method
        const generatedItems = await service._populateRooms(grid, options);

        console.log(`Generated ${generatedItems.length} items.`);

        let violations = 0;

        for (const item of generatedItems) {
            // Find which room this item belongs to
            // Item center
            const itemCx = item.x + item.width / 2;
            const itemCy = item.y + item.height / 2;

            // Check against all rooms (padded)
            let inRoom = false;
            for (const room of grid.rooms) {
                // Room bounds in PIXELS
                const minX = room.x * gridSize + padding;
                const minY = room.y * gridSize + padding;
                const maxX = (room.x + room.width) * gridSize + padding;
                const maxY = (room.y + room.height) * gridSize + padding;

                // Check containment (loose check allowing for item size?)
                // The item x,y is topleft.
                // Strict containment: item must be fully inside?
                // The placement logic is:
                // rx = room.x + PADDING + random(...)
                // px = rx * gridSize + padding

                // So px should be >= minX + gridSize (if PADDING=1)

                if (item.x >= minX && item.x < maxX &&
                    item.y >= minY && item.y < maxY) {
                    inRoom = true;
                    // Check if it matches THIS room specifically
                    // It should.
                    break;
                }
            }

            if (!inRoom) {
                console.error(`Item at ${item.x}, ${item.y} is NOT inside any room!`);
                violations++;
            }
        }

        if (violations === 0) {
            console.log("SUCCESS: All items are with room bounds (accounting for padding).");
        } else {
            console.error(`FAILURE: ${violations} items generated outside rooms.`);
            process.exit(1);
        }

    } catch (e) {
        console.error("Test failed:", e);
        process.exit(1);
    }
}

function setupCanvasMock() {
    // Basic mock for canvas 2d context for generateDungeonWithData
    // We don't need it to actually draw, just not crash.
    global.window.HTMLCanvasElement.prototype.getContext = () => ({
        translate: () => { },
        fillRect: () => { },
        drawImage: () => { },
        imageSmoothingEnabled: false,
        createPattern: () => ({}),
        fillStyle: '',
        strokeStyle: '',
        lineWidth: 0,
        lineCap: '',
        beginPath: () => { },
        moveTo: () => { },
        lineTo: () => { },
        stroke: () => { },
        fillText: () => { },
        strokeText: () => { },
        measureText: () => ({ width: 0 }),
    });

    global.window.HTMLCanvasElement.prototype.toBlob = (cb) => cb(new Blob([], { type: 'image/png' }));
}

test();
